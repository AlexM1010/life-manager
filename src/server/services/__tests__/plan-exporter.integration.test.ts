import { describe, it, expect, beforeEach, vi } from 'vitest';
import { drizzle } from 'drizzle-orm/better-sqlite3';
import Database from 'better-sqlite3';
import * as schema from '../../db/schema.js';
import { domains } from '../../db/schema.js';
import { PlanExporter } from '../plan-exporter.js';
import { GoogleCalendarClient } from '../google-calendar-client.js';
import { TodayPlan } from '../planner.js';
import { google } from 'googleapis';

/**
 * Integration tests for Plan Exporter
 * 
 * Tests full export flow with mocked Google Calendar API.
 * 
 * Requirements: 1.1, 1.2, 1.3
 */

// Mock googleapis
vi.mock('googleapis', () => {
  const mockCalendar = {
    calendarList: {
      list: vi.fn(),
    },
    calendars: {
      insert: vi.fn(),
    },
    events: {
      list: vi.fn(),
      insert: vi.fn(),
      delete: vi.fn(),
    },
  };

  return {
    google: {
      calendar: vi.fn(() => mockCalendar),
      auth: {
        OAuth2: vi.fn(),
      },
    },
  };
});

describe('PlanExporter - Integration', () => {
  let db: ReturnType<typeof drizzle<typeof schema>>;
  let exporter: PlanExporter;
  let calendarClient: GoogleCalendarClient;
  let mockCalendar: any;
  let mockOAuth2Client: any;

  beforeEach(async () => {
    vi.clearAllMocks();

    // Create in-memory database
    const sqlite = new Database(':memory:');
    db = drizzle(sqlite, { schema });

    // Create tables
    sqlite.exec(`
      CREATE TABLE domains (
        id INTEGER PRIMARY KEY AUTOINCREMENT,
        name TEXT NOT NULL UNIQUE,
        description TEXT NOT NULL DEFAULT '',
        why_it_matters TEXT NOT NULL DEFAULT '',
        boring_but_important INTEGER NOT NULL DEFAULT 0,
        created_at TEXT NOT NULL,
        updated_at TEXT NOT NULL
      );
    `);

    // Insert test domains
    await db.insert(domains).values([
      {
        name: 'Relationships',
        description: 'Family and friends',
        whyItMatters: 'Connection matters',
        boringButImportant: false,
        createdAt: '2024-01-01T00:00:00Z',
        updatedAt: '2024-01-01T00:00:00Z',
      },
      {
        name: 'Health',
        description: 'Physical and mental health',
        whyItMatters: 'Health is foundational',
        boringButImportant: false,
        createdAt: '2024-01-01T00:00:00Z',
        updatedAt: '2024-01-01T00:00:00Z',
      },
    ]);

    // Setup mocks
    calendarClient = new GoogleCalendarClient();
    exporter = new PlanExporter(calendarClient, db);
    mockCalendar = google.calendar('v3');
    
    mockOAuth2Client = {
      setCredentials: vi.fn(),
      credentials: {
        access_token: 'test-token',
      },
    };
  });

  describe('getOrCreatePlanCalendar', () => {
    it('should return existing calendar ID if found', async () => {
      // Mock calendar list with existing plan calendar
      mockCalendar.calendarList.list.mockResolvedValue({
        data: {
          items: [
            { id: 'primary', summary: 'Primary Calendar' },
            { id: 'plan-cal-123', summary: "Life Manager - Today's Plan" },
          ],
        },
      });

      const calendarId = await exporter.getOrCreatePlanCalendar(mockOAuth2Client);

      expect(calendarId).toBe('plan-cal-123');
      expect(mockCalendar.calendarList.list).toHaveBeenCalledWith({
        auth: mockOAuth2Client,
      });
      expect(mockCalendar.calendars.insert).not.toHaveBeenCalled();
    });

    it('should create new calendar if not found', async () => {
      // Mock calendar list without plan calendar
      mockCalendar.calendarList.list.mockResolvedValue({
        data: {
          items: [
            { id: 'primary', summary: 'Primary Calendar' },
          ],
        },
      });

      // Mock calendar creation
      mockCalendar.calendars.insert.mockResolvedValue({
        data: {
          id: 'new-plan-cal-456',
          summary: "Life Manager - Today's Plan",
        },
      });

      const calendarId = await exporter.getOrCreatePlanCalendar(mockOAuth2Client);

      expect(calendarId).toBe('new-plan-cal-456');
      expect(mockCalendar.calendars.insert).toHaveBeenCalledWith({
        auth: mockOAuth2Client,
        requestBody: expect.objectContaining({
          summary: "Life Manager - Today's Plan",
          description: expect.stringContaining('Daily plan generated by Life Manager'),
        }),
      });
    });
  });

  describe('clearTodaysPlanEvents', () => {
    it('should delete all events for the specified date', async () => {
      const calendarId = 'plan-cal-123';
      const date = '2024-02-09';

      // Mock existing events
      mockCalendar.events.list.mockResolvedValue({
        data: {
          items: [
            { id: 'event1', summary: '[!!!] Task 1 (15m)' },
            { id: 'event2', summary: '[!!] Task 2 (10m)' },
          ],
        },
      });

      mockCalendar.events.delete.mockResolvedValue({});

      await exporter.clearTodaysPlanEvents(mockOAuth2Client, calendarId, date);

      expect(mockCalendar.events.list).toHaveBeenCalledWith({
        auth: mockOAuth2Client,
        calendarId,
        timeMin: expect.any(String),
        timeMax: expect.any(String),
        singleEvents: true,
      });

      expect(mockCalendar.events.delete).toHaveBeenCalledTimes(2);
      expect(mockCalendar.events.delete).toHaveBeenCalledWith({
        auth: mockOAuth2Client,
        calendarId,
        eventId: 'event1',
      });
      expect(mockCalendar.events.delete).toHaveBeenCalledWith({
        auth: mockOAuth2Client,
        calendarId,
        eventId: 'event2',
      });
    });

    it('should handle empty calendar gracefully', async () => {
      const calendarId = 'plan-cal-123';
      const date = '2024-02-09';

      mockCalendar.events.list.mockResolvedValue({
        data: {
          items: [],
        },
      });

      await exporter.clearTodaysPlanEvents(mockOAuth2Client, calendarId, date);

      expect(mockCalendar.events.delete).not.toHaveBeenCalled();
    });
  });

  describe('exportPlan', () => {
    it('should export complete plan to Google Calendar', async () => {
      const plan: TodayPlan = {
        date: '2024-02-09',
        energyLevel: 7,
        items: [
          {
            taskId: 1,
            task: {
              id: 1,
              title: 'Call Mom',
              description: 'Weekly check-in',
              domainId: 1,
              priority: 'must-do',
              estimatedMinutes: 15,
              dueDate: null,
              status: 'todo',
              rrule: null,
              createdAt: '2024-01-01T00:00:00Z',
              updatedAt: '2024-01-01T00:00:00Z',
            },
            category: 'must-do',
          },
          {
            taskId: 2,
            task: {
              id: 2,
              title: 'Exercise',
              description: null,
              domainId: 2,
              priority: 'should-do',
              estimatedMinutes: 30,
              dueDate: null,
              status: 'todo',
              rrule: null,
              createdAt: '2024-01-01T00:00:00Z',
              updatedAt: '2024-01-01T00:00:00Z',
            },
            category: 'health',
          },
        ],
      };

      // Mock calendar operations
      mockCalendar.calendarList.list.mockResolvedValue({
        data: {
          items: [
            { id: 'plan-cal-123', summary: "Life Manager - Today's Plan" },
          ],
        },
      });

      mockCalendar.events.list.mockResolvedValue({
        data: { items: [] },
      });

      mockCalendar.events.insert.mockResolvedValue({
        data: { id: 'new-event-id' },
      });

      await exporter.exportPlan(plan, mockOAuth2Client);

      // Verify calendar was found/created
      expect(mockCalendar.calendarList.list).toHaveBeenCalled();

      // Verify events were cleared
      expect(mockCalendar.events.list).toHaveBeenCalled();

      // Verify events were created
      expect(mockCalendar.events.insert).toHaveBeenCalledTimes(2);

      // Verify first event
      const firstCall = mockCalendar.events.insert.mock.calls[0][0];
      expect(firstCall.requestBody.summary).toBe('[!!!] Call Mom (15m)');
      expect(firstCall.requestBody.description).toContain('Domain: Relationships');
      expect(firstCall.requestBody.description).toContain('Task ID: 1');
      expect(firstCall.requestBody.description).toContain('Status: pending');
      expect(firstCall.requestBody.extendedProperties.private.lifeManagerTaskId).toBe('1');

      // Verify second event
      const secondCall = mockCalendar.events.insert.mock.calls[1][0];
      expect(secondCall.requestBody.summary).toBe('[!!] Exercise (30m)');
      expect(secondCall.requestBody.description).toContain('Domain: Health');
      expect(secondCall.requestBody.description).toContain('Task ID: 2');
    });

    it('should handle empty plan gracefully', async () => {
      const plan: TodayPlan = {
        date: '2024-02-09',
        energyLevel: 3,
        items: [],
      };

      mockCalendar.calendarList.list.mockResolvedValue({
        data: {
          items: [
            { id: 'plan-cal-123', summary: "Life Manager - Today's Plan" },
          ],
        },
      });

      mockCalendar.events.list.mockResolvedValue({
        data: { items: [] },
      });

      await exporter.exportPlan(plan, mockOAuth2Client);

      // Should still clear calendar but not create any events
      expect(mockCalendar.events.list).toHaveBeenCalled();
      expect(mockCalendar.events.insert).not.toHaveBeenCalled();
    });
  });
});
