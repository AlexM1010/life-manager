import { GoogleCalendarClient } from './google-calendar-client.js';
import { TodayPlan, TodayPlanItem } from './planner.js';
import { drizzle } from 'drizzle-orm/better-sqlite3';
import { eq } from 'drizzle-orm';
import * as schema from '../db/schema.js';

/**
 * Plan Exporter Service
 * 
 * Exports daily plans to a dedicated Google Calendar for Life Launcher to read.
 * 
 * Requirements: 1.1, 1.2, 1.3
 */

export class PlanExporter {
  private readonly PLAN_CALENDAR_NAME = "Life Manager - Today's Plan";
  
  constructor(
    private calendarClient: GoogleCalendarClient,
    private db: ReturnType<typeof drizzle<typeof schema>>
  ) {}

  /**
   * Export today's plan to Google Calendar
   * Called after generatePlan() or on schedule
   * 
   * Validates: Requirements 1.1, 1.2, 1.3
   * 
   * @param plan - Generated daily plan
   * @param oauth2Client - Configured OAuth2 client (auto-refreshes tokens)
   */
  async exportPlan(plan: TodayPlan, oauth2Client: any): Promise<void> {
    try {
      // 1. Get or create the plan calendar
      const calendarId = await this.getOrCreatePlanCalendar(oauth2Client);

      // 2. Clear today's existing plan events
      await this.clearTodaysPlanEvents(oauth2Client, calendarId, plan.date);

      // 3. Fetch domain information for all tasks
      const domainIds = Array.from(new Set(plan.items.map(item => item.task.domainId)));
      const domainRecords = await this.db
        .select()
        .from(schema.domains)
        .where(eq(schema.domains.id, domainIds[0])); // Start with first domain

      // Fetch all domains if multiple
      const allDomains = domainIds.length > 1
        ? await this.db.select().from(schema.domains)
        : domainRecords;

      const domainMap = new Map(allDomains.map(d => [d.id, d.name]));

      // 4. Create events for each task with simple time-blocking
      // Start at 9 AM by default
      const [year, month, day] = plan.date.split('-').map(Number);
      let currentTime = new Date(year, month - 1, day, 9, 0, 0);

      for (const item of plan.items) {
        const domainName = domainMap.get(item.task.domainId) || 'Unknown';
        
        await this.createPlanEvent(
          oauth2Client,
          calendarId,
          item,
          domainName,
          currentTime
        );

        // Advance time for next task
        currentTime = new Date(
          currentTime.getTime() + item.task.estimatedMinutes * 60 * 1000
        );
      }
    } catch (error) {
      throw new Error(
        `Failed to export plan: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
    }
  }

  /**
   * Get or create the "Life Manager - Today's Plan" calendar
   * 
   * Validates: Requirement 1.2
   * 
   * @param oauth2Client - Configured OAuth2 client
   * @returns Calendar ID
   */
  async getOrCreatePlanCalendar(oauth2Client: any): Promise<string> {
    const { google } = await import('googleapis');
    const calendar = google.calendar('v3');

    try {
      // List all calendars to find the plan calendar
      const calendarList = await calendar.calendarList.list({
        auth: oauth2Client,
      });

      const calendars = calendarList.data.items || [];
      const existingCalendar = calendars.find(
        (cal) => cal.summary === this.PLAN_CALENDAR_NAME
      );

      if (existingCalendar?.id) {
        return existingCalendar.id;
      }

      // Calendar doesn't exist, create it
      const newCalendar = await calendar.calendars.insert({
        auth: oauth2Client,
        requestBody: {
          summary: this.PLAN_CALENDAR_NAME,
          description: 'Daily plan generated by Life Manager. Read by Life Launcher widget.',
          timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,
        },
      });

      if (!newCalendar.data.id) {
        throw new Error('Failed to create plan calendar: no ID returned');
      }

      return newCalendar.data.id;
    } catch (error) {
      throw new Error(
        `Failed to get or create plan calendar: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
    }
  }

  /**
   * Clear today's plan events before exporting new plan
   * 
   * Validates: Requirement 1.3
   * 
   * @param oauth2Client - Configured OAuth2 client
   * @param calendarId - Plan calendar ID
   * @param date - Date to clear (ISO format YYYY-MM-DD)
   */
  async clearTodaysPlanEvents(
    oauth2Client: any,
    calendarId: string,
    date: string
  ): Promise<void> {
    const { google } = await import('googleapis');
    const calendar = google.calendar('v3');

    try {
      // Parse date and create start/end of day
      const [year, month, day] = date.split('-').map(Number);
      const startOfDay = new Date(year, month - 1, day, 0, 0, 0);
      const endOfDay = new Date(year, month - 1, day, 23, 59, 59);

      // Fetch all events for the date
      const response = await calendar.events.list({
        auth: oauth2Client,
        calendarId,
        timeMin: startOfDay.toISOString(),
        timeMax: endOfDay.toISOString(),
        singleEvents: true,
      });

      const events = response.data.items || [];

      // Delete each event
      for (const event of events) {
        if (event.id) {
          try {
            await calendar.events.delete({
              auth: oauth2Client,
              calendarId,
              eventId: event.id,
            });
          } catch (error) {
            // Log but continue - don't fail entire clear operation
            console.error(`Failed to delete event ${event.id}:`, error);
          }
        }
      }
    } catch (error) {
      throw new Error(
        `Failed to clear plan events: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
    }
  }

  /**
   * Create a calendar event for a planned task
   * 
   * Validates: Requirement 1.2
   * 
   * @param oauth2Client - Configured OAuth2 client
   * @param calendarId - Plan calendar ID
   * @param item - Plan item to export
   * @param domainName - Domain name for the task
   * @param startTime - Start time for the event
   */
  async createPlanEvent(
    oauth2Client: any,
    calendarId: string,
    item: TodayPlanItem,
    domainName: string,
    startTime: Date
  ): Promise<string> {
    const { google } = await import('googleapis');
    const calendar = google.calendar('v3');

    try {
      const title = this.encodeTaskTitle(item);
      const description = this.encodeTaskDescription(item, domainName);

      // Calculate end time
      const endTime = new Date(startTime.getTime() + item.task.estimatedMinutes * 60 * 1000);

      // Create event
      const response = await calendar.events.insert({
        auth: oauth2Client,
        calendarId,
        requestBody: {
          summary: title,
          description,
          start: {
            dateTime: startTime.toISOString(),
            timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,
          },
          end: {
            dateTime: endTime.toISOString(),
            timeZone: Intl.DateTimeFormat().resolvedOptions().timeZone,
          },
          extendedProperties: {
            private: {
              lifeManagerTaskId: item.taskId.toString(),
              category: item.category,
            },
          },
        },
      });

      if (!response.data.id) {
        throw new Error('No event ID returned from Google Calendar');
      }

      return response.data.id;
    } catch (error) {
      throw new Error(
        `Failed to create plan event: ${error instanceof Error ? error.message : 'Unknown error'}`
      );
    }
  }

  /**
   * Encode task title in format: [!!!] Title (15m)
   * 
   * @param item - Plan item
   * @returns Encoded title
   */
  encodeTaskTitle(item: TodayPlanItem): string {
    // Map priority to marker
    const priorityMarker: Record<string, string> = {
      'must-do': '[!!!]',
      'should-do': '[!!]',
      'nice-to-have': '[!]',
    };

    const marker = priorityMarker[item.task.priority] || '[!]';
    const title = item.task.title;
    const duration = item.task.estimatedMinutes;

    return `${marker} ${title} (${duration}m)`;
  }

  /**
   * Encode task description with metadata
   * 
   * Format:
   * Domain: [domain name]
   * Task ID: [id]
   * Category: [must-do|want-to|health]
   * Status: pending
   * 
   * @param item - Plan item
   * @param domainName - Domain name
   * @returns Encoded description
   */
  encodeTaskDescription(item: TodayPlanItem, domainName: string): string {
    const lines = [
      `Domain: ${domainName}`,
      `Task ID: ${item.taskId}`,
      `Category: ${item.category}`,
      `Status: pending`,
    ];

    // Add task description if available
    if (item.task.description) {
      lines.push('');
      lines.push(item.task.description);
    }

    return lines.join('\n');
  }
}
